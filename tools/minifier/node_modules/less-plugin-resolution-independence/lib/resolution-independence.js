// Adding a "plugin" that works with LESS 1.7, for converting pixel measurements to resolution
// independent units i.e. rems.
;(function(){

	var less;
	if (typeof window != 'undefined') {
		less = window.less || {};
	} else {
		less = require("less");
	}

	/**
	* The configurable options that can be passed into `ResolutionIndependence`.
	*
	* @typedef {Object} ResolutionIndependence~Options
	* @property {Number} baseSize - The root font-size we wish to use to base all of our conversions
	*	upon.
	* @property {String} riUnit - The unit of measurement to we wish to use for
	*	resolution-independent units.
	* @property {String} unit - The unit of measurement to that we wish to convert to
	*	resolution-independent units.
	* @property {String} unit - The unit of measurement to ignore for resolution-independence
	*	conversion, and instead should be 1:1 converted to our `_unit` unit.
	*/

	var ResolutionIndependence = function (opts) {
		this._baseSize = opts && opts.baseSize || this._baseSize;
		this._riUnit = opts && opts.riUnit || this._riUnit;
		this._unit = opts && opts.unit || this._unit;
		this._ignoreUnit = opts && opts.ignoreUnit || this._ignoreUnit;
	};

	ResolutionIndependence.prototype = {

		/**
		* The root font-size we wish to use to base all of our conversions upon.
		*
		* @type {Number}
		* @default 12
		* @private
		*/
		_baseSize: 12,

		/**
		* The unit of measurement to we wish to use for resolution-independent units.
		*
		* @type {String}
		* @default 'rem'
		* @private
		*/
		_riUnit: 'rem',

		/**
		* The unit of measurement to that we wish to convert to resolution-independent units.
		*
		* @type {String}
		* @default 'px'
		* @private
		*/
		_unit: 'px',

		/**
		* The unit of measurement to ignore for resolution-independence conversion, and instead
		* should be 1:1 converted to our `_unit` unit.
		*
		* @type {String}
		* @default 'apx'
		* @private
		*/
		_ignoreUnit: 'apx', // "absolute" px

		/*
		* Entry point
		*/
		run: function (root) {
			this._visitor = this._visitor || new less.tree.visitor(this);
			return this._visitor.visit(root);
		},

		/*
		* Hook into each rule node
		*
		* @private
		*/
		visitRule: function (node) {
			var valueNode = node && !node.inline && node.value && node.value.value && node.value.value.length && node.value.value[0],
				stringValues;

			// The value(s) of a CSS function call
			if (Array.isArray(valueNode.args)) {
				valueNode.args.forEach(this.convertValue.bind(this));
			}
			// Multiple property values where at least one value is a LESS variable (LESS
			// automatically converts all of the values into array items)
			else if (Array.isArray(valueNode.value)) {
				valueNode.value.forEach(this.convertValue.bind(this));
			}
			// Directly set string values that have a number
			else if (typeof valueNode.value == 'string' && valueNode.value.match(/\d+/g)) {
				stringValues = valueNode.value.match(/\S+/g) || [];
				valueNode.value = stringValues.map(this.parseValue.bind(this)).join(' ');
			}
			// A single value
			else {
				this.convertValue(valueNode);
			}

			return node;
		},

		/**
		* Takes a LESS rule node and converts the value to a resolution-independent measurement. If
		* the rule node's value is a string value, the value and unit will be set as the updated
		* value of this node. If the rule node consists of a value object and unit object, both of
		* these objects will be updated with the appropriate values.
		*
		* @param {Object} valueNode - The rule node we are currently examining and will convert.
		* @private
		*/
		convertValue: function (valueNode) {
			var value = valueNode.value,
				unitNode = valueNode.unit,
				unit = unitNode && unitNode.numerator && unitNode.numerator.length && unitNode.numerator[0],
				result;

			result = this.parseValue(value, unit);

			if (unit && result && result.unit) {
				valueNode.value = result.value;
				unitNode.numerator[0] = result.unit;
			} else if (result) {
				valueNode.value = result;
			}
		},

		/**
		* Examines a value and optional unit, and converts to a resolution-independent measurement.
		*
		* @param {String} value - The value, usually a number, to be converted.
		* @param {String} [unit] - The current unit of our value measurement. If this is provided,
		*	we assume that we are dealing with a value object and a unit object and will return an
		*	object instead of a string.
		* @returns {String | Object} If we are converting a string value, we return a concatenated
		*	string value consisting of the converted value and unit. If we are converting an object,
		*	such as when we have separate value and unit values, we return an object consisting of
		*	the converted value and unit as separate properties. If no conversion occurs, we return
		*	the original value that was provided.
		* @private
		*/
		parseValue: function (value, unit) {
			if (value && value.toString().slice(-1*this._ignoreUnit.length) == this._ignoreUnit) {
				return parseInt(value, 10) + this._unit;
			} else if (value && value.toString().slice(-1*this._unit.length) == this._unit) {
				return parseInt(value, 10) / this._baseSize + this._riUnit;
			} else if (unit && unit == this._unit) {
				return {
					value: value / this._baseSize,
					unit: this._riUnit
				};
			}

			return value;
		}
	};

	if (typeof window != 'undefined') {
		window.enyoLessRiPlugin = ResolutionIndependence;
	} else {
		module.exports = ResolutionIndependence;
	}

}());
