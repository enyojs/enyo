// Adding a "plugin" that works with LESS 1.7, for converting pixel measurements to resolution
// independent units i.e. rems.
;(function(){

	var less;
	if (typeof window != 'undefined') {
		less = window.less || {};
	} else {
		less = require("less");
	}

	/**
	* The configurable options that can be passed into `ResolutionIndependence`.
	*
	* @typedef {Object} ResolutionIndependence~Options
	* @property {Number} baseSize - The root font-size we wish to use to base all of our conversions
	*	upon.
	* @property {String} riUnit - The unit of measurement to we wish to use for
	*	resolution-independent units.
	* @property {String} unit - The unit of measurement to that we wish to convert to
	*	resolution-independent units.
	* @property {String} absoluteUnit - The unit of measurement to ignore for
	*	resolution-independence conversion, and instead should be 1:1 converted to our `_unit` unit.
	* @property {Number} minUnitSize - The minimum unit size (as an absolute value) that any
	*	measurement should be valued at the lowest device resolution we wish to support. This allows
	*	for meaningful measurements that are not unnecessarily scaled down excessively.
	* @property {Number} minSize - The root font-size corresponding to the lowest device resolution
	*	we wish to support. This is utilized in conjunction with the `minUnitSize` property.
	* @property {Number} precision - How precise our measurements will be, namely the maximum amount
	*	of fractional digits that will appear in our converted measurements.
	*/

	var ResolutionIndependence = function (opts) {
		this._baseSize = opts && opts.baseSize || this._baseSize;
		this._riUnit = opts && opts.riUnit || this._riUnit;
		this._unit = opts && opts.unit || this._unit;
		this._absoluteUnit = opts && opts.absoluteUnit || this._absoluteUnit;
		this._minUnitSize = opts && opts.minUnitSize || this._minUnitSize;
		this._minSize = opts && opts.minSize || this._minSize;
		this._precision = opts && opts.precision || this._precision;

		// One-time computation of the minimum scale factor that will be used for determining
		// whether or not to clamp measurement values to the minimum unit size `_minUnitSize`.
		this._minScaleFactor = this._minSize / this._baseSize;
	};

	ResolutionIndependence.prototype = {

		/**
		* The root font-size we wish to use to base all of our conversions upon.
		*
		* @type {Number}
		* @default 24
		* @private
		*/
		_baseSize: 24,

		/**
		* The unit of measurement to we wish to use for resolution-independent units.
		*
		* @type {String}
		* @default 'rem'
		* @private
		*/
		_riUnit: 'rem',

		/**
		* The unit of measurement to that we wish to convert to resolution-independent units.
		*
		* @type {String}
		* @default 'px'
		* @private
		*/
		_unit: 'px',

		/**
		* The unit of measurement to ignore for resolution-independence conversion, and instead
		* should be 1:1 converted to our `_unit` unit.
		*
		* @type {String}
		* @default 'apx'
		* @private
		*/
		_absoluteUnit: 'apx', // "absolute" px

		/**
		* The minimum unit size (as an absolute value), in our base unit `_unit`, that any
		* measurement should be set to in the resolution corresponding to our minimum root font-size
		* `_minSize`.
		*
		* @type {Number}
		* @default 1
		* @private
		*/
		_minUnitSize: 1,

		/**
		* The root font-size corresponding to the lowest device resolution we wish to support. The
		* determination for adjusting our measurements based on the minimum unit `_minUnitSize` are
		* dependent on this value.
		*
		* @type {String}
		* @default 16
		* @private
		*/
		_minSize: 16,

		/**
		* This number is a representation of how precise our measurements should be. More
		* specifically, this number corresponds to the maximum number of fractional digits in our
		* computed measurements. This will not affect measurements that utilize the `_absoluteUnit`
		* unit, or measurements that are adjusted to the minimum unit size, in the event that
		* `_minUnitSize` has more precision than what is specified here, as `_minUnitSize` would be
		* user-overridden and assumed intentional.
		* 
		* @type {Number}
		* @default 5
		* @private
		*/
		_precision: 5,

		/*
		* Entry point
		*/
		run: function (root) {
			this._visitor = this._visitor || new less.tree.visitor(this);
			return this._visitor.visit(root);
		},

		/*
		* Hook into each rule node
		*
		* @private
		*/
		visitRule: function (node) {
			var ruleNode = node && !node.inline && node.value && node.value.value && node.value.value.length && node.value.value[0],
				stringValues;

			// The value(s) of a CSS function call
			if (Array.isArray(ruleNode.args)) {
				ruleNode.args.forEach(this.updateNode.bind(this));
			}
			// Multiple property values where at least one value is a LESS variable (LESS
			// automatically converts all of the values into array items)
			else if (Array.isArray(ruleNode.value)) {
				ruleNode.value.forEach(this.updateNode.bind(this));
			}
			// Directly set string values that have a number
			else if (typeof ruleNode.value == 'string' && ruleNode.value.match(/\d+/g)) {
				stringValues = ruleNode.value.match(/\S+/g) || [];
				ruleNode.value = stringValues.map(this.parseValueString.bind(this)).join(' ');
			}
			// A single value
			else {
				this.updateNode(ruleNode);
			}
		},

		/**
		* Takes a LESS rule node and updates the value to a resolution-independent measurement. If
		* the rule node's value is a string value, the value and unit will be set as the updated
		* value of this node. If the rule node consists of a value object and unit object, both of
		* these objects will be updated with the appropriate values.
		*
		* @param {Object} ruleNode - The rule node we are currently examining and will convert.
		* @private
		*/
		updateNode: function (ruleNode) {
			if (ruleNode) {
				var value = ruleNode.value,
					unitNode = ruleNode.unit,
					result;

				if (unitNode) {
					result = this.parseValueObject(value, unitNode);
					ruleNode.value = result.value;
					unitNode.numerator[0] = result.unit;
				} else {
					ruleNode.value = this.parseValueString(value);
				}
			}
		},

		/**
		* Parses measurement values that have a separate unit object.
		* 
		* @param {Number} value - The measurement value we wish to convert.
		* @param {Object} unitNode - An object representing the unit associated with the measurement
		*	value.
		* @returns {Object} An object with `value` and `unit` properties that represent the
		*	measurement in resolution-independent units.
		* @private
		*/
		parseValueObject: function (value, unitNode) {
			var unit = (unitNode && unitNode.numerator && unitNode.numerator.length && unitNode.numerator[0]) || unitNode.backupUnit,
				scaledValue;

			// The standard unit to convert (if no unit, we assume the base unit)
			if (unit == this._unit) {
				scaledValue = Math.abs(value * this._minScaleFactor);
				return (scaledValue && scaledValue <= this._minUnitSize) ? 
					{
						value: Math.abs(value) < this._minUnitSize ? value : this._minUnitSize * (value < 0 ? -1 : 1),
						unit: this._unit
					} :
					{
						value: this.convertValue(value),
						unit: this._riUnit
					};
			}
			// The absolute unit to convert to our standard unit
			else if (unit == this._absoluteUnit) {
				return {
					value: value,
					unit: this._unit
				};
			}

			return {
				value: value,
				unit: unit
			};
		},

		/**
		* Parses measurements that contain both the value and unit as a single string.
		* 
		* @param {String} value - The measurement in the base unit which we wish to convert.
		* @returns {String} The measurement, in resolution-independent units.
		* @private
		*/
		parseValueString: function (value) {
			var scaledValue;

			// String value in our absolute unit
			if (value && value.toString().slice(-1*this._absoluteUnit.length) == this._absoluteUnit) {
				return parseFloat(value) + this._unit;
			}
			// String value in our to-be-converted unit
			else if (value && value.toString().slice(-1*this._unit.length) == this._unit) {
				value = parseFloat(value);
				scaledValue = Math.abs(value * this._minScaleFactor);
				return (scaledValue && scaledValue <= this._minUnitSize) ?
					(Math.abs(value) < this._minUnitSize ?
						value + this._unit : this._minUnitSize * (value < 0 ? -1 : 1) + this._unit) :
					this.convertValue(value) + this._riUnit;
			}

			return value;
		},

		/**
		* Converts a value from our base unit to a value in resolution-independent units.
		* 
		* @param {Number} value - The value, in base units, to be converted to a value that is in
		*	resolution-independent units.
		* @returns {Number} - The converted value in resolution-independent units.
		* @private
		*/
		convertValue: function (value) {
			return parseFloat((value / this._baseSize).toFixed(this._precision));
		}
	};

	if (typeof window != 'undefined') {
		window.enyoLessRiPlugin = ResolutionIndependence;
	} else {
		module.exports = ResolutionIndependence;
	}

}());